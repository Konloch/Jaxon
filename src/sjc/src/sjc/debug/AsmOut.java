/* Copyright (C) 2016, 2019 Stefan Frenz
 *
 * This file is part of SJC, the Small Java Compiler written by Stefan Frenz.
 *
 * SJC is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SJC is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SJC. If not, see <http://www.gnu.org/licenses/>.
 */

package sjc.debug;

import sjc.compbase.*;
import sjc.memory.ImageContainer;
import sjc.memory.MemoryImage;
import sjc.memory.MemoryObjectDebugInfo;
import sjc.osio.TextPrinter;

/**
 * AsmOut: basic functions for symbol information writer
 *
 * @author S. Frenz
 * @version 190322 fixed ex-/implicit conversion
 * version 161212 now always escaping ' and "
 * version 161117 added MthdHead
 * version 160328 initial version
 */

public abstract class AsmOut extends DebugLister
{
	protected Context ctx;
	protected TextPrinter out;
	protected ImageContainer img;
	
	protected abstract void setMthdFlag(boolean nextIsMthd);
	
	protected abstract void printHeader(MemoryImage mem);
	
	protected abstract void printMthdHead(MemoryObjectDebugInfo now, Mthd mthd);
	
	protected abstract void printMthdTail(MemoryObjectDebugInfo now, Mthd mthd);
	
	public AsmOut(String filename, Context ictx)
	{
		out = (ctx = ictx).osio.getNewFilePrinter(filename);
	}
	
	public void globalRAMInfo(boolean isDecompressor, Object ramInitLoc, int ramSize, int constMemorySize)
	{
		if (isDecompressor)
			out.println(";--- Decompressor ---");
	}
	
	public void listMemory(MemoryImage mem)
	{
		Unit unit;
		Mthd mthd;
		String string;
		
		if (ctx.mem instanceof ImageContainer)
			img = (ImageContainer) ctx.mem;
		else
		{
			out.println("memory error, see compilation output");
			ctx.out.println("AsmOut debug lister: memory is not readable, can not dump it");
			return;
		}
		
		out.println(";--- assembler output generated by SJC ---");
		printHeader(mem);
		
		MemoryObjectDebugInfo now = mem.getFirstDebugListerObject();
		while (now != null)
		{
			if (now.source instanceof Mthd)
			{
				setMthdFlag(true);
				mthd = (Mthd) now.source;
				out.print(";--- start of method ");
				out.print(mthd.owner.name);
				out.print(".");
				mthd.printNamePar(out);
				out.println();
				printMthdHead(now, mthd);
				printRelocs(now.pointer, now.relocs);
				printObjectScalars(now.pointer, ctx.codeStart, ctx.rteSMthdBlock, false, now.pointer);
				out.print(mthd.asmCode);
				printMthdTail(now, mthd);
			}
			else
			{
				setMthdFlag(false);
				if (now.source instanceof Unit)
				{
					unit = (Unit) now.source;
					out.print(";--- start of class desc for unit ");
					unit.printNameWithOuter(out);
					out.println();
					printSClassDescRelocs(now.pointer, now.relocs, unit);
					unit.printNameWithOuter(out, '$');
					out.println("$clss:");
					printSClassDescScalars(now.pointer, now.scalarSize, unit);
				}
				else if (now.source instanceof String)
				{
					string = (String) now.source;
					out.println(";--- start of String inst");
					printRelocs(now.pointer, now.relocs);
					if (ctx.langString.inlArr != null)
					{
						printObjectScalars(now.pointer, ctx.langString.instScalarTableSize, ctx.langString, false, 0);
						printEscapedString(string, now.scalarSize - ctx.langString.instScalarTableSize);
					}
					else
					{
						printObjectScalars(now.pointer, now.scalarSize, ctx.langString, false, 0);
						now = now.next; //next object is char-array that belongs to given string
						printRelocs(now.pointer, now.relocs);
						printObjectScalars(now.pointer, ctx.rteSArray.instScalarTableSize, ctx.rteSArray, false, 0);
						printEscapedString(string, now.scalarSize - ctx.rteSArray.instScalarTableSize);
					}
				}
				else
				{
					//if (now.source!=null) System.out.println("missing special implementation for now.source type "+now.source.getClass().getName());
					out.println(";--- start of common object");
					printRelocs(now.pointer, now.relocs);
					printObjectScalars(now.pointer, now.scalarSize, null, false, 0);
				}
			}
			now = now.next;
		}
	}
	
	public void finalizeImageInfo()
	{
	}
	
	protected int getMemValue(int addr, int size)
	{
		int value = 0;
		int shift = 0;
		while (size-- > 0)
		{
			value |= ((int) img.memBlock[addr - img.baseAddress] & 0xFF) << shift;
			addr++;
			shift += 8;
		}
		return value;
	}
	
	protected void printGeneralObjPtr(int pointer)
	{
		printRelocLabel(pointer);
		out.println(":");
	}
	
	protected void printRelocLabel(int pointer)
	{
		if (pointer != 0)
		{
			out.print("$_A_");
			out.printHexFix(pointer, 8);
		}
		else
			out.print("0");
	}
	
	protected void printRelocs(int pointer, int relocs)
	{
		int i;
		for (i = relocs; i > 0; i--)
			printReloc(pointer - i * ctx.arch.relocBytes);
	}
	
	protected void printReloc(int pointer)
	{
		switch (ctx.arch.relocBytes)
		{
			case 1:
				out.print("  db ");
				break;
			case 2:
				out.print("  dw ");
				break;
			case 4:
				out.print("  dd ");
				break;
			case 8:
				out.print("  dq ");
				break;
		}
		printRelocLabel(getMemValue(pointer, ctx.arch.relocBytes));
		out.print("   ;");
		out.printHexFix(pointer, 8);
		out.println();
	}
	
	protected void printSClassDescRelocs(int pointer, int relocs, Unit unit)
	{
		int i, off;
		AccVar var;
		Mthd mthd;
		for (i = relocs; i > 0; i--)
		{
			off = -i * ctx.arch.relocBytes;
			var = searchVar(unit, AccVar.L_CLSSREL, off, false);
			if (var == null)
				var = searchVar(ctx.rteSClassDesc, AccVar.L_INSTREL, off, true);
			if (var != null)
			{
				ctx.printUniqueVarName(out, var, unit);
				out.println(":");
			}
			else
			{
				mthd = searchMthd(unit, off);
				if (mthd != null)
				{
					ctx.printUniqueMethodName(out, mthd, unit);
					out.println("$ref:");
				}
			}
			printScalar(pointer + off, ctx.arch.relocBytes);
		}
	}
	
	protected void printObjectScalars(int pointer, int scalarSize, Unit unit, boolean withNames, int mthdPointerForScalarCalc)
	{
		AccVar var = null;
		int off = 0, size;
		while (off < scalarSize)
		{
			size = 1;
			if (unit != null)
				var = searchVar(unit, AccVar.L_INSTSCL, off, true);
			if (var != null)
			{
				if (withNames)
				{
					ctx.printUniqueVarName(out, var, unit);
					out.println(":");
				}
				size = var.minSize;
			}
			if (unit != null && off == 4 && mthdPointerForScalarCalc != 0)
			{ //_r_scalarSize
				printScalarDecl(size);
				out.print(' ');
				printRelocLabel(mthdPointerForScalarCalc);
				out.print("end - ");
				printRelocLabel(mthdPointerForScalarCalc);
				out.println();
			}
			else
				printScalar(pointer + off, size);
			off += size;
		}
	}
	
	protected void printSClassDescScalars(int pointer, int scalarSize, Unit unit)
	{
		AccVar var;
		int off = 0, size;
		while (off < scalarSize)
		{
			size = 1;
			var = searchVar(unit, AccVar.L_CLSSSCL, off, false);
			if (var == null)
				var = searchVar(ctx.rteSClassDesc, AccVar.L_INSTSCL, off, true);
			if (var != null)
			{
				ctx.printUniqueVarName(out, var, unit);
				out.println(":");
				size = var.minSize;
			}
			printScalar(pointer + off, size);
			off += size;
		}
	}
  
  /*protected void printInlineArrayScalars(int pointer, int scalarSize, Unit unit) {
    int entrySize=unit.inlArr.minSize;
    int entries=(scalarSize-unit.instScalarTableSize)/entrySize;
    for (int i=0; i<entries; i++) printValue(pointer, unit.instScalarTableSize+i*entrySize, entrySize);
  }*/
	
	protected void printEscapedString(String what, int desiredByteLength)
	{
		int i;
		if (ctx.byteString)
			out.print("  db ");
		else
			out.print("  dw ");
		for (i = 0; i < what.length(); i++)
		{
			if (i > 0)
				out.print(',');
			char c = what.charAt(i);
			if (c < 32 || c > 127)
			{
				out.print("0x");
				out.printHexFix(c, 2);
			}
			else if (c == '\'' || c == '"' || c == '\\')
			{
				out.print("'\\");
				out.print(c);
				out.print('\'');
			}
			else
			{
				out.print('\'');
				out.print(c);
				out.print('\'');
			}
			if (ctx.byteString)
				desiredByteLength--;
			else
				desiredByteLength -= 2;
		}
		out.println();
		if (desiredByteLength > 0)
		{
			out.print("  db ");
			i = 0;
			while (i < desiredByteLength)
			{
				if (i > 0)
					out.print(',');
				out.print('0');
				i++;
			}
			out.println();
		}
	}
	
	protected void printScalarDecl(int size)
	{
		switch (size)
		{
			case 1:
				out.print("  db");
				break;
			case 2:
				out.print("  dw");
				break;
			case 4:
				out.print("  dd");
				break;
			case 8:
				out.print("  dq");
				break;
			default:
				out.print("  --invalid-scalar-decl-size--");
		}
	}
	
	protected void printScalar(int pointer, int size)
	{
		if (size > ctx.arch.relocBytes)
		{ //too big for single access, split into multiple smaller portions
			while (size > 0)
			{
				printScalar(pointer, ctx.arch.relocBytes);
				pointer += ctx.arch.relocBytes;
				size -= ctx.arch.relocBytes;
			}
			return;
		}
		printGeneralObjPtr(pointer);
		printScalarDecl(size);
		out.print(" 0x");
		out.printHexFix(getMemValue(pointer, size), size * 2);
		out.println();
	}
	
	protected Mthd searchMthd(Unit unit, int offset)
	{
		Mthd mthds;
		boolean stat = true;
		while (unit != null)
		{
			mthds = unit.mthds;
			while (mthds != null)
			{
				if (mthds.relOff == offset && (stat || (mthds.modifier & Modifier.M_STAT) == 0))
					return mthds;
				mthds = mthds.nextMthd;
			}
			if (unit.extsID != null)
				unit = unit.extsID.unitDest;
			else
				unit = null;
			stat = false;
		}
		return null;
	}
	
	protected AccVar searchVar(Unit unit, int reqLocation, int offset, boolean searchParents)
	{
		Vrbl vars;
		while (unit != null)
		{
			vars = unit.vars;
			while (vars != null)
			{
				if (vars.location == reqLocation && vars.relOff == offset)
					return vars;
				vars = vars.nextVrbl;
			}
			if (searchParents && unit.extsID != null)
				unit = unit.extsID.unitDest;
			else
				unit = null;
		}
		return null;
	}
}
