/* Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2012 Stefan Frenz
 *
 * This file is part of SJC, the Small Java Compiler written by Stefan Frenz.
 *
 * SJC is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SJC is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SJC. If not, see <http://www.gnu.org/licenses/>.
 */

package sjc.ui;

import sjc.backend.ssa.SSADef;

import java.io.FileInputStream;
import java.io.IOException;

/**
 * ChkSSA: check created SSA-binaries
 *
 * @author S. Frenz
 * @version 120305 removed unused variables
 * version 101101 adopted changed of genDeref
 * version 090717 added I_STKCHK
 * version 090207 added copyright notice
 * version 080616 added I_TF*
 * version 080508 added I_FLOWHINT
 * version 080203 added I_ENTERINL and I_LEAVEINL to support method inlining
 * version 070912 added new instruction for inlineVarOffset
 * version 061202 adopted change of genCall
 * version 061111 ignoring not-read results of method calls
 * version 060714 changed bound semantics
 * version 060616 updated save-restore-strategy
 * version 060610 added register-test on call
 * version 060609 added allocation and killing strategy tests
 * version 060607 initial version
 */

public class ChkSSA
{
	private static int fileOffset, insOffset, lineCnt;
	private static FileInputStream fis;
	private static String filename;
	private static int[] usage;
	private static int blockBaseRegNr, lastAllocReg;
	
	private static final int R_ALLOCED = 0x1;
	private static final int R_KILLED = 0x2;
	private static final int R_WRITTEN = 0x4;
	private static final int R_READ = 0x8;
	private static final int R_SAVED = 0x10;
	private static final int R_BITSHFT = 8;
	
	public static void main(String[] args)
	{
		int i, param, type;
		int reg0 = 0, reg1 = 0, reg2 = 0;
		int iPar1 = 0, iPar2 = 0;
		
		if (args == null || args.length < 1 || args.length > 1)
		{
			System.out.println("Checker for pseudo-SSA-code generated by SC");
			System.out.println("Please give a file to translate as parameter");
			return;
		}
		
		try
		{
			fis = new FileInputStream(args[0]);
		}
		catch (IOException e)
		{
			System.out.print("Could not open file: ");
			System.out.println(e.getMessage());
			return;
		}
		
		filename = args[0];
		fileOffset = 0;
		blockBaseRegNr = 0;
		lastAllocReg = SSADef.R_GPRS - 1;
		
		try
		{
			while (fis.available() > 0)
			{
				lineCnt++;
				insOffset = fileOffset;
				//get type and parameter
				param = readByte();
				type = readByte();
				//check for jump-destination
				if ((param & SSADef.IPJMPDEST) != 0)
				{
					lineCnt++;
					param &= ~SSADef.IPJMPDEST;
          /*for (i=SSADef.R_GPRS; i<usage.length; i++) {
            if ((usage[i]&(R_ALLOCED|R_KILLED))==R_ALLOCED) printErr("jumpDest: register in use", i);
          }*/
				}
				if (type == (0xFF & SSADef.I_INLINE))
				{ //MAGIC.inline
					while (param-- > 0)
						readByte(); //skip bytes
				}
				else if (type == (0xFF & SSADef.I_JUMP))
				{ //jump
					readByte(); //step over condition
					readInt(); //step over relative
				}
				else
				{ //normal instruction
					param = param << SSADef.IPOPTSHFT;
					//fetch parameters
					if ((param & SSADef.IP_reg0) != 0)
						reg0 = readInt();
					if ((param & SSADef.IP_reg1) != 0)
						reg1 = readInt();
					if ((param & SSADef.IP_reg2) != 0)
						reg2 = readInt();
					if ((param & SSADef.IP_size) != 0)
						iPar1 = readByte();
					else if ((param & SSADef.IP_im_i) != 0)
						iPar1 = readInt();
					if ((param & SSADef.IP_para) != 0)
						iPar2 = readInt();
					if ((param & SSADef.IP_im_l) != 0)
						readLong(); //lPar=readLong();
					//check instruction
					switch (type)
					{
						//          nothing to check
						case 0xFF & SSADef.I_MARKER:
						case 0xFF & SSADef.I_ENTER:
						case 0xFF & SSADef.I_ENTERINL:
						case 0xFF & SSADef.I_LEAVE:
						case 0xFF & SSADef.I_LEAVEINL:
						case 0xFF & SSADef.I_PUSHim_i:
						case 0xFF & SSADef.I_PUSHim_l:
						case 0xFF & SSADef.I_PUSHnp:
						case 0xFF & SSADef.I_JUMP:
						case 0xFF & SSADef.I_CALLim_p:
						case 0xFF & SSADef.I_REGRANGE:
						case 0xFF & SSADef.I_KILLOJMP:
						case 0xFF & SSADef.I_EXCEPT:
						case 0xFF & SSADef.I_IVOF:
						case 0xFF & SSADef.I_FLOWHINT: //maybe sometimes the id has to be checked
						case 0xFF & SSADef.I_TFUPD1:
						case 0xFF & SSADef.I_TFUPD2:
							break;
						//          create buffer for register-usage
						case 0xFF & SSADef.I_NFREG:
							usage = new int[iPar1];
							break;
						//          check write to reg0 as it is loaded with constant
						case 0xFF & SSADef.I_LOADim_i:
						case 0xFF & SSADef.I_LOADnp:
						case 0xFF & SSADef.I_POP:
							usage[reg0] |= R_WRITTEN; //checkWrite(reg0);
							checkRegType(reg0, iPar1);
							break;
						case 0xFF & SSADef.I_LOADim_p:
							usage[reg0] |= R_WRITTEN; //checkWrite(reg0);
							checkRegType(reg0, -1);
							break;
						case 0xFF & SSADef.I_REST:
							checkRegType(reg0, iPar1);
							restReg(reg0, iPar2);
							break;
						case 0xFF & SSADef.I_LOADim_l:
						case 0xFF & SSADef.I_MOVEMAP:
							checkWrite(reg0);
							break;
						//          check write to reg0 and read of reg1, unary operation
						case 0xFF & SSADef.I_LOADval:
							checkWrite(reg0);
							checkRead(reg1);
							checkRegType(reg0, iPar1);
							checkRegType(reg1, -1);
							break;
						case 0xFF & SSADef.I_COPY:
							if (reg1 != SSADef.R_PRIR)
								checkWrite(reg0); //copy after call without reg-alloc
							else
								usage[reg0] |= R_WRITTEN | R_READ; //R_READ: no error if result of call is not read
							checkRead(reg1);
							checkRegType(reg0, iPar1);
							checkRegType(reg1, iPar1);
							break;
						case 0xFF & SSADef.I_CONV:
							checkWrite(reg0);
							checkRead(reg1);
							checkRegType(reg0, iPar1);
							checkRegType(reg1, iPar2);
							break;
						case 0xFF & SSADef.I_LOADaddr:
							checkWrite(reg0);
							checkRead(reg1);
							checkRegType(reg0, -1);
							break;
						case 0xFF & SSADef.I_NOT:
						case 0xFF & SSADef.I_NEG:
							checkWrite(reg0);
							checkRead(reg1);
							checkRegType(reg0, iPar1);
							checkRegType(reg1, iPar1);
							break;
						case 0xFF & SSADef.I_BINV:
							checkWrite(reg0);
							checkRead(reg1);
							checkRegType(reg0, 1);
							checkRegType(reg1, 1);
							break;
						case 0xFF & SSADef.I_IN:
							checkWrite(reg0);
							checkRead(reg1);
							checkRegType(reg0, iPar1);
							checkRegType(reg1, -1);
							break;
						case 0xFF & SSADef.I_DEREF:
							checkWrite(reg0);
							checkRead(reg1);
							checkRead(reg2);
							break;
						//          check read of reg0 as it is used as address or single operand
						case 0xFF & SSADef.I_PUSH:
							checkRead(reg0);
							checkRegType(reg0, iPar1);
							break;
						case 0xFF & SSADef.I_SAVE:
							//checkRead(reg0); //this makes only sense if SSA is extended to remember written registers
							checkRegType(reg0, iPar1);
							saveReg(reg0, iPar2);
							break;
						case 0xFF & SSADef.I_INCmem:
						case 0xFF & SSADef.I_DECmem:
							checkRead(reg0);
							checkRegType(reg0, -1);
							break;
						case 0xFF & SSADef.I_CALL:
						case 0xFF & SSADef.I_CALLind:
							checkRead(reg0);
							checkCall();
							break;
						//          check read of reg0 and reg1, used for assign and compare etc.
						case 0xFF & SSADef.I_ASSIGN:
						case 0xFF & SSADef.I_OUT:
							checkRead(reg0);
							checkRead(reg1);
							checkRegType(reg0, -1);
							checkRegType(reg1, iPar1);
							break;
						case 0xFF & SSADef.I_CMP:
							checkRead(reg0);
							checkRead(reg1);
							checkRegType(reg0, iPar1);
							checkRegType(reg1, iPar1);
							break;
						case 0xFF & SSADef.I_BOUND:
							checkRead(reg0);
							checkRead(reg1);
							break;
						//          check write of reg0 and read of reg1, reg2 for binary operation
						case 0xFF & SSADef.I_AND:
						case 0xFF & SSADef.I_XOR:
						case 0xFF & SSADef.I_OR:
						case 0xFF & SSADef.I_ADD:
						case 0xFF & SSADef.I_SUB:
						case 0xFF & SSADef.I_MUL:
						case 0xFF & SSADef.I_DIV:
						case 0xFF & SSADef.I_MOD:
							checkWrite(reg0);
							checkRead(reg1);
							checkRead(reg2);
							checkRegType(reg0, iPar1);
							checkRegType(reg1, iPar1);
							checkRegType(reg2, iPar1);
							break;
						case 0xFF & SSADef.I_SHL:
						case 0xFF & SSADef.I_SHRL:
						case 0xFF & SSADef.I_SHRA:
							checkWrite(reg0);
							checkRead(reg1);
							checkRead(reg2);
							checkRegType(reg0, iPar1);
							checkRegType(reg1, iPar1);
							checkRegType(reg2, 4);
							break;
						case 0xFF & SSADef.I_ALLOCREG:
							allocReg(reg0, iPar1);
							break;
						case 0xFF & SSADef.I_KILLREG:
							killReg(reg0);
							break;
						case 0xFF & SSADef.I_TFBUILD:
						case 0xFF & SSADef.I_TFRESET:
							checkRead(reg0);
							checkRegType(reg0, -1);
							break;
						case 0xFF & SSADef.I_STKCHK:
							checkRead(reg0);
							break;
						default:
							System.out.println("###unknown instruction param/type: " + param + "/" + type + " in file " + filename);
							fis.close();
							return;
					}
				}
			}
			fis.close();
			for (i = SSADef.R_GPRS; i < usage.length; i++)
				checkRegUsed(i);
		}
		catch (IOException e)
		{
			System.out.println("Error in processing file: " + e.getMessage());
			return;
		}
	}
	
	private static int readByte() throws IOException
	{
		fileOffset++;
		return fis.read() & 0xFF;
	}
	
	private static int readInt() throws IOException
	{
		return readByte() | (readByte() << 8) | (readByte() << 16) | (readByte() << 24);
	}
	
	private static long readLong() throws IOException
	{
		long l0, l1;
		l0 = readInt() & 0xFFFFFFFF;
		l1 = readInt() & 0xFFFFFFFF;
		return l0 | (l1 << 32);
	}
	
	private static void allocReg(int reg, int size)
	{
		if (reg >= SSADef.R_GPRS)
		{
			if ((usage[reg] & (R_ALLOCED | R_KILLED)) != 0)
				printErr("alloc: register already allocated", reg);
			if (reg <= lastAllocReg)
				printErr("alloc: register allocation order wrong", reg);
			if (blockBaseRegNr == 0)
				blockBaseRegNr = reg;
			else if (reg < blockBaseRegNr)
				printErr("alloc: register allocated below block base", reg);
			usage[reg] = R_ALLOCED | (size << R_BITSHFT);
			lastAllocReg = reg;
		}
	}
	
	private static void killReg(int reg)
	{
		int cmp;
		
		if ((usage[reg] & (R_ALLOCED | R_KILLED)) != R_ALLOCED)
			printErr("kill: register not allocated or killed already", reg);
		else
			for (cmp = reg + 1; cmp <= lastAllocReg; cmp++)
			{
				if ((usage[cmp] & (R_ALLOCED | R_KILLED)) == R_ALLOCED)
				{
					printErr("kill: register killing not in reverse allocation order", reg);
					break;
				}
				if (blockBaseRegNr == reg)
					blockBaseRegNr = lastAllocReg + 1;
			}
		usage[reg] |= R_KILLED;
	}
	
	private static void saveReg(int reg, int sc)
	{
		if ((usage[reg] & (R_ALLOCED | R_KILLED)) != R_ALLOCED)
			printErr("save: register not allocated or killed already", reg);
		else
		{
			usage[reg] = usage[reg] | R_SAVED;
		}
	}
	
	private static void restReg(int reg, int rc)
	{
		if (rc == 1 && (usage[reg] & (R_ALLOCED | R_KILLED | R_SAVED)) != (R_ALLOCED | R_SAVED))
			printErr("rest: register not saved or killed already", reg);
		else
			usage[reg] = usage[reg] | R_ALLOCED;
	}
	
	private static void checkWrite(int reg)
	{
		if (reg >= SSADef.R_GPRS)
		{
			if ((usage[reg] & (R_ALLOCED | R_KILLED)) != R_ALLOCED)
				printErr("write: register not allocated", reg);
			//if ((usage[reg]&R_WRITTEN)!=0)
			//  printErr("write: register already written", reg);
			usage[reg] |= R_WRITTEN; //register is written
			usage[reg] &= ~R_READ; //clear read-flag as this write is possibly needless
		}
	}
	
	private static void checkRead(int reg)
	{
		if (reg >= SSADef.R_GPRS)
		{
			if ((usage[reg] & (R_ALLOCED | R_KILLED)) != R_ALLOCED)
				printErr("read: register not allocated", reg);
			if ((usage[reg] & R_WRITTEN) != R_WRITTEN)
				printErr("read: register not written", reg);
			usage[reg] |= R_READ;
		}
	}
	
	private static void checkRegUsed(int reg)
	{
		if ((usage[reg] & R_ALLOCED) == 0)
			printErr("checkUse: register unallocated", reg);
		if ((usage[reg] & R_KILLED) == 0)
			printErr("checkUse: register not killed", reg);
		if ((usage[reg] & R_READ) == 0)
			printErr("checkUse: register not read", reg);
	}
	
	private static void checkRegType(int reg, int size)
	{
		int cur;
		
		if (reg >= SSADef.R_GPRS)
		{
			size &= 0xFF; //only lower 8 bits are used (so "-1" gets 0xFF)
			//check if width maches, only dptr may be accessed as ptr
			if ((cur = (usage[reg] >>> R_BITSHFT)) != size && (size != 0xFF || cur != 0xFE))
				printErr("checkSize: " + cur + "!=" + size, reg);
		}
	}
	
	private static void checkCall()
	{
		//    int reg;
		//
		//    if (blockBaseRegNr!=0) for (reg=blockBaseRegNr; reg<lastAllocReg; reg++) {
		//      if ((usage[reg]&(R_ALLOCED|R_KILLED|R_WRITTEN))==(R_ALLOCED|R_WRITTEN))
		//        printErr("register not killed or saved before call ("+(usage[reg]&0x1F)+")", reg);
		//    }
	}
	
	private static void printErr(String msg, int reg)
	{
		System.out.println(filename + ":" + insOffset + ":" + lineCnt + ": " + msg + " (r" + reg + ")");
	}
}
